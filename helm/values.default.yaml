deployment:
  replicas: 1

  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  image:
    repository: "ghcr.io/crowley723"
    tag: ""  # defaults to Chart.AppVersion
    pullPolicy: "IfNotPresent"

  imagePullSecrets: []
  # - name: myregistrykey

  serviceAccount: ""

  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

  labels: {}
  annotations: {}
  podLabels: {}
  podAnnotations: {}

  container:
    name: "dashboard"
    command: []
    args: []

    additionalPorts: []
    # - name: metrics
    #   port: 9090
    #   protocol: TCP

    env: {}
    # CONFIG_FILE: "/etc/dashboard/config.yaml"
    # LOG_LEVEL: "info"

    envFrom: []
    # - secretRef:
    #     name: dashboard-secrets

    # Volume mounts (config is auto-mounted if configMap.generate=true)
    volumeMounts: []
    # - name: data
    #   mountPath: /data
    #   readOnly: false

    livenessProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3

    readinessProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3

    startupProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 30

    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 0m
        memory: 0Mi

    # Container security context
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
          - ALL

  # Sidecar containers
  sidecars: []
  # - name: log-shipper
  #   image: fluent/fluent-bit:latest
  #   volumeMounts:
  #   - name: logs
  #     mountPath: /var/log

  # Additional volumes (config volume is auto-created if configMap.generate=true)
  volumes: []
  # - name: data
  #   persistentVolumeClaim:
  #     claimName: dashboard-data

service:
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: http  # references the container port name
  # clusterIP: ""
  # loadBalancerIP: ""
  # loadBalancerSourceRanges: []
  # externalIPs: []
  # nodePort: 30080
  # sessionAffinity: None
  # externalTrafficPolicy: Cluster

  # Additional service ports
  additionalPorts: []
  # - name: metrics
  #   port: 9090
  #   targetPort: 9090
  #   protocol: TCP

  # Additional labels and annotations
  labels: {}
  annotations: {}

ingressRoute:
  enabled: false

  entryPoints:
    - web
    - websecure

  routes:
    - match: "Host(`dashboard.local`)"
      # priority: 10  # Optional route priority
      # middlewares:  # Optional middlewares
      #   - name: auth
      #     namespace: default
      #   - name: rate-limit
      servicePort: 80  # Optional, defaults to service.port
      # scheme: http    # Optional: http or https
      # strategy: ""    # Optional load balancing strategy
      # weight: 100     # Optional service weight
      # sticky:         # Optional sticky sessions
      #   cookie:
      #     name: server
      #     secure: true
      #     httpOnly: true
      # healthCheck:    # Optional health check
      #   path: /health
      #   interval: 30s
      #   timeout: 3s

  # TLS configuration
  tls:
    # Option 1: Use existing secret
    # secretName: dashboard-tls-secret

    # Option 2: Use cert resolver (Let's Encrypt)
    certResolver: letsencrypt-prod
    domains:
      - main: dashboard.local
        # sans:  # Subject Alternative Names
        #   - www.dashboard.local
        #   - api.dashboard.local

    # Option 3: Use TLS store and options
    # store:
    #   name: default
    #   namespace: traefik-system
    # options:
    #   name: default
    #   namespace: traefik-system

  # TCP routes (optional)
  tcpRoute:
    enabled: false
    entryPoints:
      - tcp-entry
    routes:
      - match: "HostSNI(`dashboard.local`)"
        servicePort: 80
    tls:
      passthrough: false
      # secretName: dashboard-tcp-tls
      # certResolver: letsencrypt-prod
      # domains:
      #   - main: dashboard.local

  # Additional labels and annotations
  labels: {}
  annotations: {}


configMap:
  generate: true
  key: "config.yaml"
  labels: {}
  annotations: {}

config:
  server:
    port: 8080
    # external_url: "https://dashboard.example.com"  # Optional: external URL for redirects
    # debug:  # Optional: enable pprof debug endpoints
    #   enabled: false
    #   host: "127.0.0.1"
    #   port: 9000

  # Distributed mode configuration (requires redis)
  distributed:
    enabled: false
    ttl: "30s"

  # Redis configuration (required for distributed mode, redis sessions, and redis cache)
  redis:
    address: "redis:6379"
    # username: ""  # Optional: set via DASHBOARD_REDIS_USERNAME
    # password: ""  # Set via secret: DASHBOARD_REDIS_PASSWORD
    session_index: 0
    cache_index: 1
    leader_index: 2
    # sentinel:  # Optional: Redis Sentinel configuration
    #   master_name: "mymaster"
    #   addresses:
    #     - "sentinel1:26379"
    #     - "sentinel2:26379"
    #     - "sentinel3:26379"
    #   password: ""  # Set via secret: DASHBOARD_REDIS_SENTINEL_PASSWORD
    #   username: ""  # Optional

  oidc:
    client_id: ""
    client_secret: ""
    issuer_url: ""
    redirect_url: ""
    scopes:
      - "openid"
      - "profile"
      - "email"
      - "groups"

  log:
    level: "info"  # debug, info, warn, error
    format: "text" # text, json

  cors:
    allowed_origins:
      - "http://localhost:5173"
      - "http://localhost:3000"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "OPTIONS"
    allowed_headers:
      - "*"
    exposed_headers: []
    allow_credentials: false
    max_age_seconds: 300

  session:
    store: "memory"          # memory, redis
    duration_source: "fixed" # fixed, oidc_tokens
    fixed_timeout: "24h"
    name: "session_id"
    secure: true

  data:
    prometheus_url: "http://prometheus:9090"
    # fallback_fetch_interval: "10m"  # Optional: fallback interval if query doesn't specify TTL
    # Basic auth for Prometheus (optional)
    # Set via secrets: DASHBOARD_DATA_BASIC_AUTH_USERNAME, DASHBOARD_DATA_BASIC_AUTH_PASSWORD
    basic_auth:
      username: ""
      password: ""
    queries:
      - name: "cpu_usage"
        disabled: false
        query: "100 - (avg(rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)"
        type: "instant"  # instant or range
        ttl: "30s"
        # range: ""  # Required for range queries
        # step: ""   # Required for range queries
        require_auth: false
        # required_group: ""  # Optional: require specific OIDC group
      - name: "memory_usage"
        disabled: false
        query: "(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100"
        type: "instant"
        ttl: "30s"
        require_auth: false
      - name: "disk_usage_over_time"
        disabled: false
        query: "100 - ((node_filesystem_avail_bytes{mountpoint=\"/\"} / node_filesystem_size_bytes{mountpoint=\"/\"}) * 100)"
        type: "range"
        ttl: "1m"
        range: "1h"
        step: "1m"
        require_auth: true
        required_group: "admin"

  cache:
    type: "memory"  # memory or redis

  # Storage configuration (required for mTLS and firewall management features)
  storage:
    enabled: false
    host: "postgres"
    port: 5432
    username: ""
    password: ""
    database: "homelab_dashboard"

  # Authorization configuration - maps OIDC groups to application scopes
  authorization:
    group_scopes:
      # mTLS management permissions
      conduit:mtls:admin:
        - "mtls:request:cert"
        - "mtls:read:all_certs"
        - "mtls:read:cert"
        - "mtls:approve:cert"
        - "mtls:renew:cert"
        - "mtls:revoke:cert"
        - "mtls:download:all_certs"
        - "mtls:download:cert"
        - "mtls:auto_approve:cert"
      conduit:mtls:user:
        - "mtls:request:cert"
        - "mtls:read:cert"
        - "mtls:renew:cert"
        - "mtls:download:cert"
      # Firewall management permissions
      conduit:firewall:admin:
        - "firewall:read:own"
        - "firewall:request:own"
        - "firewall:revoke:own"
        - "firewall:read:all"
        - "firewall:revoke:all"
        - "firewall:blacklist"
      conduit:firewall:database_access:
        - "firewall:read:own"
        - "firewall:request:own"
        - "firewall:revoke:own"
      conduit:firewall:vpn_access:
        - "firewall:read:own"
        - "firewall:request:own"
        - "firewall:revoke:own"

  # Optional features configuration
  features:
    # mTLS certificate management
    mtls_management:
      enabled: false
      # download_token_hmac_key: ""  # Set via secret: DASHBOARD_MTLS_DOWNLOAD_TOKEN_HMAC_KEY
      auto_approve_admin_requests: false
      allow_admins_to_approve_own_requests: true
      min_certificate_validity_days: 30
      max_certificate_validity_days: 365
      kubernetes:
        namespace: "conduit"
        in_cluster: true
        # kubeconfig: ""  # Optional: path to kubeconfig for out-of-cluster
      certificate_issuer:
        name: "selfsigned-issuer"
        kind: "ClusterIssuer"
      certificate_subject:
        organization: "Homelab Conduit"
        country: ""
        locality: ""
        province: ""
      background_job_config:
        approved_certificate_polling_interval: "30s"
        issued_certificate_polling_interval: "30s"

    # Firewall IP whitelist management (OPNsense integration)
    firewall_management:
      enabled: false
      # Router credentials set via secrets:
      # - DASHBOARD_FIREWALL_ROUTER_ENDPOINT
      # - DASHBOARD_FIREWALL_ROUTER_API_KEY
      # - DASHBOARD_FIREWALL_ROUTER_API_SECRET
      background_job_config:
        sync_interval: "5m"
        expiration_interval: "1h"
      aliases: []
        # Example alias configuration:
        # - name: "Database"
        #   uuid: "c0daef37-718c-40e4-bb2b-ba5aab418d0d"  # Get from OPNsense
        #   description: "PostgreSQL Database Access"
        #   max_ips_per_user: 5
        #   max_total_ips: 100
        #   default_ttl: null  # null = no expiration, or use duration like "720h"
        #   auth_group: "conduit:firewall:database_access"
        # - name: "VPNUsers"
        #   uuid: "7f93ff45-6c60-4a21-9767-3fc246f4d335"
        #   description: "VPN Access"
        #   max_ips_per_user: 3
        #   max_total_ips: 50
        #   default_ttl: "720h"  # 30 days
        #   auth_group: "conduit:firewall:vpn_access"