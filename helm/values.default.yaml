deployment:
  replicas: 1

  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  image:
    repository: "ghcr.io/crowley723"
    tag: ""  # defaults to Chart.AppVersion
    pullPolicy: "IfNotPresent"

  imagePullSecrets: []
  # - name: myregistrykey

  serviceAccount: ""

  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000

  nodeSelector: {}
  tolerations: []
  affinity: {}
  topologySpreadConstraints: []

  labels: {}
  annotations: {}
  podLabels: {}
  podAnnotations: {}

  container:
    name: "dashboard"
    command: []
    args: []

    additionalPorts: []
    # - name: metrics
    #   port: 9090
    #   protocol: TCP

    env: {}
    # CONFIG_FILE: "/etc/dashboard/config.yaml"
    # LOG_LEVEL: "info"

    envFrom: []
    # - secretRef:
    #     name: dashboard-secrets

    # Volume mounts (config is auto-mounted if configMap.generate=true)
    volumeMounts: []
    # - name: data
    #   mountPath: /data
    #   readOnly: false

    livenessProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 3

    readinessProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 5
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3

    startupProbe:
      httpGet:
        path: /api/v1/health
        port: http
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 30

    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 0m
        memory: 0Mi

    # Container security context
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
          - ALL

  # Sidecar containers
  sidecars: []
  # - name: log-shipper
  #   image: fluent/fluent-bit:latest
  #   volumeMounts:
  #   - name: logs
  #     mountPath: /var/log

  # Additional volumes (config volume is auto-created if configMap.generate=true)
  volumes: []
  # - name: data
  #   persistentVolumeClaim:
  #     claimName: dashboard-data

service:
  enabled: true
  type: ClusterIP
  port: 80
  targetPort: http  # references the container port name
  # clusterIP: ""
  # loadBalancerIP: ""
  # loadBalancerSourceRanges: []
  # externalIPs: []
  # nodePort: 30080
  # sessionAffinity: None
  # externalTrafficPolicy: Cluster

  # Additional service ports
  additionalPorts: []
  # - name: metrics
  #   port: 9090
  #   targetPort: 9090
  #   protocol: TCP

  # Additional labels and annotations
  labels: {}
  annotations: {}

ingressRoute:
  enabled: false

  entryPoints:
    - web
    - websecure

  routes:
    - match: "Host(`dashboard.local`)"
      # priority: 10  # Optional route priority
      # middlewares:  # Optional middlewares
      #   - name: auth
      #     namespace: default
      #   - name: rate-limit
      servicePort: 80  # Optional, defaults to service.port
      # scheme: http    # Optional: http or https
      # strategy: ""    # Optional load balancing strategy
      # weight: 100     # Optional service weight
      # sticky:         # Optional sticky sessions
      #   cookie:
      #     name: server
      #     secure: true
      #     httpOnly: true
      # healthCheck:    # Optional health check
      #   path: /health
      #   interval: 30s
      #   timeout: 3s

  # TLS configuration
  tls:
    # Option 1: Use existing secret
    # secretName: dashboard-tls-secret

    # Option 2: Use cert resolver (Let's Encrypt)
    certResolver: letsencrypt-prod
    domains:
      - main: dashboard.local
        # sans:  # Subject Alternative Names
        #   - www.dashboard.local
        #   - api.dashboard.local

    # Option 3: Use TLS store and options
    # store:
    #   name: default
    #   namespace: traefik-system
    # options:
    #   name: default
    #   namespace: traefik-system

  # TCP routes (optional)
  tcpRoute:
    enabled: false
    entryPoints:
      - tcp-entry
    routes:
      - match: "HostSNI(`dashboard.local`)"
        servicePort: 80
    tls:
      passthrough: false
      # secretName: dashboard-tcp-tls
      # certResolver: letsencrypt-prod
      # domains:
      #   - main: dashboard.local

  # Additional labels and annotations
  labels: {}
  annotations: {}


configMap:
  generate: true
  key: "config.yaml"
  labels: {}
  annotations: {}

config:
  server:
    port: 8080

  oidc:
    client_id: ""
    client_secret: ""
    issuer_url: ""
    redirect_url: ""
    scopes:
      - "openid"
      - "profile"
      - "email"
      - "groups"

  log:
    level: "info"  # debug, info, warn, error
    format: "text" # text, json

  cors:
    allowed_origins:
      - "http://localhost:5173"
      - "http://localhost:3000"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
      - "OPTIONS"
    allowed_headers:
      - "*"
    exposed_headers: []
    allow_credentials: false
    max_age_seconds: 300

  sessions:
    store: "memory"          # memory, redis
    duration_source: "fixed" # fixed, token
    fixed_timeout: "24h"
    name: "session_id"
    secure: true

  data:
    prometheus_url: "http://prometheus:9090"
    time_interval: "5m"
    # Basic auth for Prometheus (optional)
    basic_auth:
      username: ""
      password: ""
    queries:
      - name: "cpu_usage"
        query: "100 - (avg(rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)"
        type: "gauge"
        ttl: "30s"
        range: ""
        step: ""
        require_auth: false
        required_group: ""
      - name: "memory_usage"
        query: "(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100"
        type: "gauge"
        ttl: "30s"
        range: ""
        step: ""
        require_auth: false
        required_group: ""
      - name: "disk_usage_over_time"
        query: "100 - ((node_filesystem_avail_bytes{mountpoint=\"/\"} / node_filesystem_size_bytes{mountpoint=\"/\"}) * 100)"
        type: "range"
        ttl: "1m"
        range: "1h"
        step: "1m"
        require_auth: true
        required_group: "admin"

  cache:
    type: "memory" # memory, redis
    redis:
      address: "redis:6379"
      password: ""
      db_index: 0